# Брокер сообщений RabbitMQ

![RabbitMQ_logo.svg.png](photo%2FRabbitMQ_logo.svg.png)

## Введение

### Проблема #1

**Когда наш сервис начинает пользоваться невероятной популярностью, то количество запросов к нему от пользователей
вырастет и наш сервис начнёт прилегать под нагрузкой.**

_Что будем делать?_

+ Отмасштабируем количество инстансов offer-service
+ Подключим кэш

![Blank diagram.png](photo%2FBlank%20diagram.png)

Время обработки запроса будет включать в себя время, за которое база ответит нам, что всё OK.

_Что будет:_

+ База, скорее всего, приляжет
+ Данные будут неконсистентными

### Проблема #2

**Наш сервис растёт и развивается и вот уже offer-service при наступлении какого-то события должен отправлять данные
в другие сервисы, чтобы что-то там инициировать.**

![Blank diagram (1).png](photo%2FBlank%20diagram%20%281%29.png)

_Что в итоге получаем:_

+ Под каждый сервис нужно писать свой собственный клиент и обрабатывать ответы от него
+ Каждый внешний сервис будет отвечать со своей собственной задержкой, по итогу наш ответ клиенту будет включать
  в себя все эти ожидания (при асинхронных запросах - ориентируемся на самый долгий ответ от внешнего сервиса)
+ Как следствие, отвечаем пользователю медленно
+ Если мы начинаем очень часто ходить во внешние сервисы, то они могут лечь под нагрузкой

## Что делает RabbitMQ?

_А давайте вы будете делать так:_

+ Все свои хотелки изложите в заказном письме
+ Письмо положите в специальный почтовый ящик
+ Адрес почтового ящика вам дадут
+ Конечного адресата вы укажете на конверте

![Blank diagram (2).png](photo%2FBlank%20diagram%20%282%29.png)

**Отправка сообщений производится с помощью единого реализованного клиента для взаимодействия с RabbitMQ. Изменяются
только параметры и содержимое самого сообщения.**

![Blank diagram (3).png](photo%2FBlank%20diagram%20%283%29.png)

**За счёт того, что RabbitMQ может держать в себе огромное количество сообщений, а вычитывать и обрабатывать мы можем их
с той скоростью, которая комфортна нашему сервису, то проблема с нагрузкой решена.**

_На самом деле, всё чуть сложнее. Сначала сообщение попадает в **exchange**, а оттуда перенаправляется в очередь с
помощью
параметра **routing_key**._

![Blank diagram (4).png](photo%2FBlank%20diagram%20%284%29.png)

_За счёт того что очереди могут хранить в себе сообщения до тех пор, пока их не вычитывают мы можем обеспечить
персистентность системы. Простыми словами, мы будем ожидать, пока потребитель сообщений подключится и сможет прочитатть
свои сообщения, сколько бы их там не нападало._

## Типы Exchange

Выделяют **четыре** типа Exchange:

+ Fanout
+ Direct
+ Topic
+ Headers

### Fanout

![Blank diagram (5).png](photo%2FBlank%20diagram%20%285%29.png)

**Exchange публикует сообщения во все очереди, в которых есть binding, игнорируя любые настройки binding _(routing keys 
или заголовки)_.**

![Blank diagram (6).png](photo%2FBlank%20diagram%20%286%29.png)

### Direct

![Blank diagram (7).png](photo%2FBlank%20diagram%20%287%29.png)

**Exchange публикует сообщения во все очереди, в которых Routing Key binding полностью совпадает с Routing Key 
Messages.**

![Blank diagram (8).png](photo%2FBlank%20diagram%20%288%29.png)